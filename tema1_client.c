/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "tema1.h"

char buf[LINESIZE];


void replaceFirstSpaceWithNewline(char *str) {
    char *start = str;
    char *end = str + strlen(str) - 1;

    // Remove leading whitespaces
    while (*start && (*start == ' ' || *start == '\t')) {
        start++;
    }

    // Remove trailing whitespaces
    while (end > start && (*end == ' ' || *end == '\t' || *end == '\n' 
		|| *end == '\r')) {
        end--;
    }

    // Null-terminate the string at the last non-whitespace character
    *(end + 1) = '\0';
}

void
tema1_prog_1(char *host, char *filename_operations)
{
	CLIENT *clnt;

#ifndef	DEBUG
	clnt = clnt_create (host, TEMA1_PROG, TEMA1_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	FILE *file = fopen(filename_operations, "r");
	if (file == NULL) {
		printf("Cannot open %s\n", filename_operations);
		exit(1);
	}

	char *user_id, *operation, *type;

	// read line by line
	while (fgets(buf, LINESIZE, file)) {
		// parse line by ','
		user_id = strtok(buf, ",");
		operation = strtok(NULL, ",");
		type = strtok(NULL, ",");
		replaceFirstSpaceWithNewline(type);

		// request operation
		if (strcmp(operation, "REQUEST") == 0) {
			int automated_refresh = atoi(type);
			request_authorization *req_a =  
				request_authorization_1(user_id, clnt);

			if (req_a->status == 1) {
				printf("USER_NOT_FOUND\n");
			} else {
				// continue operations
				// create param to call approve request
				approve_request_params *approve_params =
					(approve_request_params *) calloc
					(1, sizeof(approve_request_params));
				approve_params->is_automatic_refreshed = automated_refresh;
				approve_params->token_value = (char *)
					calloc (SIZE_USER_ID, sizeof(char));
				if (!approve_params->token_value) {
					printf("Allocation approve_params->token_value failed\n");
					exit(1);
				}
				memcpy(approve_params->token_value, req_a->request_token,
					SIZE_USER_ID);
				token *new_token = approve_request_token_1(*approve_params,
					clnt);

				// create param to call request access
				request_access_token_params *acces_token_params =
					(request_access_token_params *) calloc
					(1, sizeof(request_access_token_params));
				if (!acces_token_params) {
					printf("Allocation acces_token_params failed\n");
					exit(1);
				}
				acces_token_params->id = (char *) calloc (SIZE_USER_ID,
					sizeof(char));
				if (!acces_token_params->id) {
					printf("Allocation acces_token_params->id failed\n");
					exit(1);
				}
				memcpy(acces_token_params->id, user_id, SIZE_USER_ID);
				acces_token_params->user_token.crt_permissions =
					new_token->crt_permissions;
				acces_token_params->user_token.is_automatic_refreshed =
					new_token->is_automatic_refreshed;
				acces_token_params->user_token.is_signed =
					new_token->is_signed;
				acces_token_params->user_token.token_value = (char *) calloc 
					(SIZE_USER_ID, sizeof(char));
				if (!acces_token_params->user_token.token_value) {
					printf("Allocation acces_token_params->user_token.token_value failed\n");
					exit(1);
				}
				acces_token_params->user_token.refresh_token = (char *) calloc
					(SIZE_USER_ID, sizeof(char));
				if (!acces_token_params->user_token.refresh_token) {
					printf("Allocation acces_token_params->user_token.refresh_token failed\n");
					exit(1);
				}
				memcpy(acces_token_params->user_token.token_value, 
					new_token->token_value, SIZE_USER_ID);
				memcpy(acces_token_params->user_token.refresh_token, 
					new_token->refresh_token, SIZE_USER_ID);
				acces_token_params->user_token.ttl = new_token->ttl;

				request_access_token *acces_token = 
					request_access_token_1(*acces_token_params, clnt);
				if (acces_token->status == 0) {
					printf("REQUEST_DENIED\n");
				} else if (!new_token->is_automatic_refreshed){
					printf("%s -> %s\n", acces_token->request_token,
						acces_token->access_token);
				} else {
					printf("%s -> %s,%s\n", acces_token->request_token,
						acces_token->access_token, acces_token->refresh_token);
				}
			}
		// action
		} else {
			// create param to call validate action
			validate_action_params *param = (validate_action_params *)
				calloc(1, sizeof(validate_action_params));
			if (!param) {
				printf("Allocation param failed\n");
				exit(1);
			}
			param->operation = (char *) calloc(sizeof(operation), sizeof(char));
			if (!param->operation) {
				printf("Allocation param->operation failed\n");
				exit(1);
			}
			param->resource = (char *) calloc(sizeof(type), sizeof(char));
			if (!param->resource) {
				printf("Allocation param->resource failed\n");
				exit(1);
			}
			param->user_id = (char *) calloc(sizeof(user_id), sizeof(char));
			if (!param->user_id) {
				printf("Allocation param->user_id failed\n");
				exit(1);
			}
			memcpy(param->user_id, user_id, SIZE_USER_ID);
			memcpy(param->resource, type, SIZE_RESOURCE_NAME);
			memcpy(param->operation, operation, SIZE_PERMISSION);
			
			int *response = validate_delegated_action_1(*param,  clnt);
			if (*response == 0) {
				printf("PERMISSION_GRANTED\n");
			} else if (*response == 1) {
				printf("PERMISSION_DENIED\n");
			} else if (*response == 2) {
				printf("TOKEN_EXPIRED\n");
			} else if (*response == 3) {
				printf("RESOURCE_NOT_FOUND\n");
			} else if (*response == 4) {
				printf("OPERATION_NOT_PERMITTED\n");
			}
		}
	}
	fclose(file);

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host, *filename_operations;

	if (argc < 3) {
		printf ("usage: %s host fisier_operatii\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	filename_operations = argv[2];

	tema1_prog_1 (host, filename_operations);
exit (0);
}