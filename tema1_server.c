/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "tema1.h"
#include "token.h"

extern approval *all_approvals;
extern user_in_db *db_users;
extern char **users, **resources;
extern int no_users, no_resources, token_valability, no_approvals, crt_approval;

request_authorization *
request_authorization_1_svc(char *arg1,  struct svc_req *rqstp)
{
	static request_authorization result;

	printf("BEGIN %s AUTHZ\n", arg1);
	result.status = 1;
	result.request_token = " ";
	for (int i = 0; i < no_users; i++) {
		if (strncmp(users[i], arg1, strlen(arg1)) == 0) {
			result.status = 0;
			result.request_token = generate_access_token(arg1);
			break;
		}
	}
	//printf("ai iesi din autho\n");
	return &result;
}

token *
approve_request_token_1_svc(char *arg1,  struct svc_req *rqstp)
{
    // for (int i = 0; i < no_approvals; i++) {
    //     for (int j = 0; j < all_approvals[i].no_permissions; j++) {
    //         printf("%s %s\n", all_approvals[i].list_permissions.list_permissions_val[j].file, all_approvals[i].list_permissions.list_permissions_val[j].permission);
    //     }
    // }

    static token result;
    result.crt_permissions = crt_approval;
    result.is_automatic_refreshed = 0;
    result.is_signed = 0;
    result.ttl = 0;
    
    // Allocate memory for token_value
    result.token_value = (char *)malloc((SIZE_USER_ID) * sizeof(char));
	if (!result.token_value) {
		printf("Allocation failed\n");
		exit(1);
	}
	result.refresh_token = (char *)malloc((SIZE_USER_ID) * sizeof(char));
	if (!result.refresh_token) {
		printf("Allocation failed\n");
		exit(1);
	}

    memcpy(result.token_value, arg1, SIZE_USER_ID);

    //printf("permisiuni date %d\n", all_approvals[crt_approval].no_permissions);

    if (strcmp(all_approvals[crt_approval].list_permissions.list_permissions_val->file, "*") == 0) {
        if (strcmp(all_approvals[crt_approval].list_permissions.list_permissions_val->permission, "-") == 0) {
            result.is_signed = 0;
        }
    } else {
        result.is_signed = 1;
    }
	crt_approval++;

    //printf("nr_crt_approval %d\n", crt_approval);

    return &result;
}

request_access_token *
request_access_token_1_svc(request_access_token_params arg1,  struct svc_req *rqstp)
{
	static request_access_token  result;
	//printf("%d\n", arg1.user_token.is_signed);
	//printf("aici acum\n");
	result.access_token = " ";
	result.refresh_token = " ";
	result.request_token = " ";
	result.status = 0;
	
	printf("  RequestToken = %s\n", arg1.user_token.token_value);
	if (arg1.user_token.is_signed == 1) {
		result.access_token = generate_access_token(arg1.user_token.token_value);
		if (arg1.user_token.is_automatic_refreshed == 1) {
			result.refresh_token = generate_access_token(result.access_token);
		}
		result.request_token = arg1.user_token.token_value;
		result.status = 1;
		for (int i = 0; i < no_users; i++) {
			if (strcmp(db_users[i].user_id, arg1.id) == 0 ) {
				db_users[i].user_token.crt_permissions = arg1.user_token.crt_permissions;
				db_users[i].user_token.is_automatic_refreshed = arg1.user_token.is_automatic_refreshed;
				db_users[i].user_token.is_signed = arg1.user_token.is_signed;
				//printf("token failed:%s\n", db_users[i].user_token.token_value);
				memcpy(db_users[i].user_token.token_value, arg1.user_token.token_value, SIZE_USER_ID);
				//db_users[i].user_token.ttl = arg1.user_token.ttl;
				//break;
			}
		}
		printf("  AccessToken = %s\n", result.access_token);
		if (arg1.user_token.is_automatic_refreshed == 1) {
			printf("  RefreshToken = %s\n", result.refresh_token);	
		}
	}

	return &result;
}

int *
validate_delegated_action_1_svc(validate_action_params arg1,  struct svc_req *rqstp)
{
	static int  result = 0;
	int is_found_user_id = 0, is_found_resource = 0, crt_permission = arg1.user_token.user_token_val->crt_permissions,
		is_found_permission_resource = 0, is_validated = 0;

	for (int i = 0; i < no_users && result == 0; i++) {
		if (strcmp(db_users[i].user_token.token_value, arg1.user_token.user_token_val->token_value) == 0) {
			is_found_user_id = 1;
			break;
		}
	}

	if (is_found_user_id == 0) {
		result = 1;
	}

	if (arg1.user_token.user_token_val->ttl <= 0 && result == 0) {
		if (arg1.user_token.user_token_val->is_automatic_refreshed == 1) {
			char *new_refresh_token = generate_access_token(arg1.user_token.user_token_val->token_value);
			memcpy(arg1.user_token.user_token_val->token_value, arg1.user_token.user_token_val->refresh_token, SIZE_USER_ID);
			memcpy(arg1.user_token.user_token_val->refresh_token, new_refresh_token, SIZE_USER_ID);
			arg1.user_token.user_token_val->ttl = token_valability;
		} else {
			result = 2;
		}
	}

	for (int i = 0; i < no_resources && result == 0; i++) {
		if (strcmp(resources[i], arg1.resource) == 0) {
			is_found_resource = 1;
			break;
		}
	}

	if (is_found_resource == 0 && result == 0) {
		result = 3;
	}


	for (int i = 0; i < all_approvals[crt_approval].no_permissions && result == 0; i++) {
		if (strcmp(all_approvals[crt_approval].list_permissions.list_permissions_val[i].file, arg1.resource) == 0) {
			is_found_permission_resource = 1;
			char *permission = (char *) calloc (sizeof char);
			char *R = strchr(permission, 'R');
			char *X = strchr(permission, 'X');
			char *M = strchr(permission, 'M');
			char *I = strchr(permission, 'I');
			char *D = strchr(permission, 'D');
			memcpy(permission, all_approvals[crt_approval].list_permissions.list_permissions_val[i].permission, SIZE_PERMISSION);
			if ((!R && strcmp(arg1.operation, 'READ') == 0) || (!X && strcmp(arg1.operation, 'EXECUTE') == 0)
				|| (!M && strcmp(arg1.operation, 'MODIFY') == 0) || (!D && strcmp(arg1.operation, 'DELETE') == 0)
				|| (!I && strcmp(arg1.operation, 'INSERT') == 0)) {
					is_validated = 1;
			}
		}
	}

	if(is_validated == 0 && result == 0) {
		result = 4;
	}

	arg1.user_token.user_token_val->ttl--;

	if (result == 0) {
		printf("PERMIT (%s,%s,%s,%d)", arg1.operation, arg1.resource, arg1.user_token.user_token_val->ttl);
	} else {
		printf("DENY (%s,%s,%s,%d)", arg1.operation, arg1.resource, arg1.user_token.user_token_val->ttl);
	}

	return &result;
}